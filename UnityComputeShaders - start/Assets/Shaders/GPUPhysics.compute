// Each #kernel tells which function to compile; you can have many kernels

// Kernels
#pragma kernel GenerateParticleValues
#pragma kernel ClearGrid
#pragma kernel PopulateGrid
#pragma kernel CollisionDetectionWithGrid
#pragma kernel CollisionDetection
#pragma kernel ComputeMomenta
#pragma kernel ComputePositionAndRotation

#define GRID_THREAD_COUNT 16
#define RIGIDBODY_THREAD_COUNT 16
#define PARTICLE_THREAD_COUNT 16
#define THRESHOLD 1E-6
#define GROUND_INDEX -1
#define EMPTY -1
#define VOXEL_SIZE 8

struct Rigidbody
{
    float3 position;
    float4 rotation;
    float3 velocity;
    float3 angularVelocity;
    int particleOffset;
};

struct Particle
{
    float3 position;
    float3 velocity;
    float3 force;
    float3 localPosition;
    float3 offsetPosition;
};

struct Voxel
{
    int buffer[VOXEL_SIZE];
};

shared RWStructuredBuffer<Rigidbody> rigidbodies;
shared RWStructuredBuffer<Particle> particles;
shared RWStructuredBuffer<Voxel> voxels;
int activeCount;
int particlesPerBody;

inline float4 quaternionConcat(const float4 q1, const float4 q2)
{
    return float4((q1.w * q2.xyz) + (q2.w * q1.xyz) + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));
}

inline float3 quaternionMul(const float4 q, const float3 v)
{
    return (dot(q.xyz, v) * q.xyz) + (q.w * q.w * v) + (2 * q.w * cross(q.xyz, v)) - cross(cross(q.xyz, v), q.xyz);
}

inline bool checkBodyActive(const int id)
{
    return id < activeCount;
}

inline bool checkParticleActive(const int id)
{
    return id < (activeCount * particlesPerBody);
}

//////////////////////////////
// Generate Particle Values //
//////////////////////////////
// Per Rigidbody
// Use rigidbody positions and
// rigidbody quaternions to
// Generate
// particle.position
// particle.offsetPosition
// particle.velocity
//
//////////////////////////////

int particleCount;
float deltaTime;
float particleMass;

[numthreads(RIGIDBODY_THREAD_COUNT, 1, 1)]
void GenerateParticleValues(uint3 id : SV_DispatchThreadID)
{
    if (!checkBodyActive(id.x)) return;

    const Rigidbody body = rigidbodies[id.x];
    for (int i = 0; i < particlesPerBody; i++)
    {
        const int index = body.particleOffset + i;
        Particle particle       = particles[body.particleOffset + i];
        particle.offsetPosition = quaternionMul(body.rotation, particle.localPosition);
        particle.position       = body.position + particle.offsetPosition;
        particle.velocity       = body.velocity + cross(body.angularVelocity, particle.offsetPosition);
        particles[index]        = particle;
    }
}

//////////////////////
// Grid Generation //
/////////////////////
// Per Grid Cell
// Use particlePositions
// to populate the
// voxelGridBuffer
/////////////////////

int3 gridDimensions;
float3 gridStartPosition;
int gridMax;
float particleDiameter;

[numthreads(GRID_THREAD_COUNT, 1, 1)]
void ClearGrid (uint3 id : SV_DispatchThreadID)
{

    Voxel voxel = voxels[id.x];
    [unroll(VOXEL_SIZE)]
    for (int i = 0; i < VOXEL_SIZE; i++)
    {
        voxel.buffer[i] = EMPTY;
    }
    voxels[id.x] = voxel;
}

// Returns the grid index for particle p
int GetParticleGridIndex(const int id)
{
    const int3 gridLocation = (particles[id].position - gridStartPosition) / particleDiameter;
    return gridLocation.x + gridDimensions.x * gridLocation.y + (gridDimensions.x * gridDimensions.y * gridLocation.z);
}

[numthreads(PARTICLE_THREAD_COUNT, 1, 1)]
void PopulateGrid (uint3 id : SV_DispatchThreadID)
{
    if (!checkParticleActive(id.x)) return;

    const int index = GetParticleGridIndex(id.x);
    if (index >= gridMax || index < 0) return;

    Voxel voxel = voxels[index];
    for (int i = 0; i < VOXEL_SIZE; i++)
    {
        if (voxel.buffer[i] == EMPTY)
        {
            voxel.buffer[i] = id.x;
            break;
        }
    }

    voxels[index] = voxel;
}

/////////////////////////
// Collision Detection //
/////////////////////////
// Per Particle
// Use particle positions, grid and velocity to compute Particle force
/////////////////////////
float springCoefficient;
float dampingCoefficient;
float tangentialCoefficient;
float gravityCoefficient;

float3 CollisionReaction(const int i, const int j)
{
    Particle first, second = particles[j];

    if (i != GROUND_INDEX)
    {
        first = particles[i];
    }
    else
    {
        first.position     = second.position;
        const float radius = particleDiameter / 2;
        first.position.y   = min(-radius, second.position.y - radius);
        first.velocity     = 0;
    }

    const float3 relativePosition = first.position - second.position;
    const float dist              = length(relativePosition);
    if (dist >= particleDiameter) return 0;

    const float3 direction          = relativePosition / dist;
    const float3 relativeVelocity   = first.velocity - second.velocity;
    const float3 tangentialVelocity = relativeVelocity - (dot(relativeVelocity, direction) * direction);

    const float3 repulsive  = -springCoefficient * (particleDiameter - dist) * direction;
    const float3 damping    = dampingCoefficient * relativeVelocity;
    const float3 tangential = tangentialCoefficient * tangentialVelocity;

    return repulsive + damping + tangential;
}

// Returns the grid location for particle p
inline int3 GetParticleGridLocation(const int id)
{
    return (particles[id].position - gridStartPosition) / particleDiameter;
}

// Converts a grid location to a grid index
inline int GetGridIndex(const int x, const int y, const int z)
{
    return x + (gridDimensions.x * y) + (gridDimensions.x * gridDimensions.y * z);
}

inline int GetGridIndex(const int3 location)
{
    return location.x + (gridDimensions.x * location.y) + (gridDimensions.x * gridDimensions.y * location.z);
}

// checks cell x,y,z for collision with i, calls CollisionReaction if so
float3 ForceFromGridCell(const int j, const int x, const int y, const int z)
{
    float3 force = 0;
    if (x < 0 || x >= gridDimensions.x || y < 0 || y >= gridDimensions.y || z < 0 || z >= gridDimensions.z) return 0;

    const int index = GetGridIndex(x, y, z);
    if (index >= gridMax) return 0;

    const Voxel voxel = voxels[index];
    [unroll(VOXEL_SIZE)]
    for (int k = 0; k < VOXEL_SIZE; k++)
    {
        const int i = voxel.buffer[k];
        if (i != EMPTY && i != j)
        {
            force += CollisionReaction(i, j);
        }
    }

    return force;
}

[numthreads(PARTICLE_THREAD_COUNT, 1, 1)]
void CollisionDetectionWithGrid (uint3 id : SV_DispatchThreadID)
{
    if (!checkParticleActive(id.x)) return;

    float3 force           = CollisionReaction(GROUND_INDEX, id.x);
    const int3 location    = GetParticleGridLocation(id.x);
    const int3 minLocation = location - 1;
    const int3 maxLocation = location + 1;

    for(int x = minLocation.x; x <= maxLocation.x; x++)
    {
        for(int y = minLocation.y; y <= maxLocation.x; y++)
        {
            for(int z = minLocation.z; z <= maxLocation.x; z++)
            {
                force += ForceFromGridCell(id.x, x, y, z);
            }
        }
    }

    force.y              -= gravityCoefficient * particleMass * deltaTime;
    particles[id.x].force = force;
}

[numthreads(PARTICLE_THREAD_COUNT, 1, 1)]
void CollisionDetection(uint3 id : SV_DispatchThreadID)
{
    if (!checkParticleActive(id.x)) return;

    float3 force = 0;
    for(int i = GROUND_INDEX; i < particleCount; i++)
    {
        if (i == (int)id.x) continue;

        force += CollisionReaction(i, id.x);
    }

    force.y              -= gravityCoefficient * particleMass * deltaTime;
    particles[id.x].force = force;
}

////////////////////////////
// Computation Of Momenta //
////////////////////////////
// Per RigidBdy
// Use particle forces to compute the force and angular force on the rigid body
////////////////////////////
float frictionCoefficient;
float linearForceScalar;
float angularFrictionCoefficient;
float angularForceScalar;

[numthreads(RIGIDBODY_THREAD_COUNT, 1, 1)]
void ComputeMomenta(uint3 id : SV_DispatchThreadID)
{
    if (!checkBodyActive(id.x)) return;

    float3 linearForce  = 0;
    float3 angularForce = 0;
    Rigidbody body      = rigidbodies[id.x];

    for (int i = 0; i < particlesPerBody; i++)
    {
        const Particle particle = particles[body.particleOffset + i];
        linearForce            += particle.force;
        angularForce           += cross(particle.offsetPosition, particle.force);
    }

    const float mass = particleMass * particlesPerBody;

    body.velocity /= 1.0 + (deltaTime * frictionCoefficient);
    body.velocity += linearForceScalar * deltaTime * linearForce * mass;

    body.angularVelocity /= 1.0 + (deltaTime * angularFrictionCoefficient);
    body.angularVelocity += angularForceScalar * deltaTime * angularForce;

    if (length(body.velocity) < THRESHOLD)
    {
        body.velocity = 0;
    }

    if (length(body.angularVelocity) < THRESHOLD)
    {
        body.angularVelocity = 0;
    }

    rigidbodies[id.x] = body;
}

/////////////////////////////
// Computation Of Position //
/////////////////////////////
// Per RigidBody
// Use rigidBodyForce and rigidBodyTorque to compute the rigid body position and rotation.
/////////////////////////////
[numthreads(RIGIDBODY_THREAD_COUNT, 1, 1)]
void ComputePositionAndRotation(uint3 id : SV_DispatchThreadID)
{
    if (!checkBodyActive(id.x)) return;

    Rigidbody body = rigidbodies[id.x];
    body.position += body.velocity * deltaTime;

    const float4 omega = float4(body.angularVelocity, 0);
    body.rotation      = normalize(body.rotation + (deltaTime * (quaternionConcat(omega, body.rotation) / 2)));

    rigidbodies[id.x] = body;
}
