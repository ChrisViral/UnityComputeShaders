#pragma kernel CSMain

#define GROUP_SIZE 256

struct Boid
{
    float3 position;
    float3 direction;
    float noise;
    float frame;
};

RWStructuredBuffer<Boid> boidsBuffer;

float time;
float deltaTime;
float rotationSpeed;
float boidSpeed;
float boidSpeedVariation;
float3 flockPosition;
float neighbourDistance;
uint boidsCount;
float boidFrameSpeed;
int frameCount;

float hash(const float n)
{
    return frac(sin(n) * 43758.5453);
}

// The noise function returns a value in the range 0 -> 1
float noise(const float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f        = f * f * (3 - (2 * f));

    const float n = p.x + p.y * 57 + 113 * p.z;
    return lerp(lerp(lerp(hash(n + 0),   hash(n + 1),   f.x),
                     lerp(hash(n + 57),  hash(n + 58),  f.x), f.y),
                lerp(lerp(hash(n + 113), hash(n + 114), f.x),
                     lerp(hash(n + 170), hash(n + 171), f.x), f.y), f.z);
}

[numthreads(GROUP_SIZE, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid boid = boidsBuffer[id.x];

    const float noiseOffset = (clamp(noise(time / 100 + boid.noise), -1, 1) * 2) - 1;
    const float speed       = boidSpeed * (1 + (noiseOffset * boidSpeedVariation)) * deltaTime;

    float3 separation = 0;
    float3 alignment  = 0;
    float3 cohesion   = flockPosition;
    uint nearby = 1;
    for (int i = 0; i < boidsCount; i++)
    {
        if ((uint)i == id.x) continue;

        const Boid other = boidsBuffer[i];
        const float dist = max(distance(boid.position, other.position), 1E-6);
        if (dist >= neighbourDistance) continue;

        nearby++;
        alignment += other.direction;
        cohesion  += other.position;

        const float3 diff = normalize(boid.position - other.position);
        separation       += diff * ((1 / dist) - (1 / neighbourDistance));
    }

    alignment /= nearby;
    cohesion  /= nearby;
    cohesion   = normalize(cohesion - boid.position);

    const float3 direction = normalize(alignment + separation + cohesion);
    const float t          = exp(-rotationSpeed * deltaTime); //This will be around 0.95
    boid.direction         = normalize(lerp(direction, boid.direction, t));
    boid.position         += boid.direction * speed;
    boid.frame             =  (boid.frame + (speed * boidFrameSpeed)) % frameCount;

    boidsBuffer[id.x] = boid;
}
