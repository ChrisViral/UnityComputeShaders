#pragma kernel CSParticle

struct Particle
{
    float3 position;
    float3 velocity;
    float life;
};

struct Vertex
{
    float3 position;
    float2 uv;
    float life;
};

// Variables set from the CPU
RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<Vertex> vertices;
float deltaTime;
float2 mousePosition;
float size;

uint rng;
uint randXorShift()
{
    // Xor Shift algorithm from George Marsaglia's paper
    rng ^= rng << 13;
    rng ^= rng >> 17;
    rng ^= rng << 5;
    return rng;
}

void respawn(const uint id)
{
    rng = id;
    const float temp = 1.0 / 4294967296.0;
    const float f0 = (randXorShift() * temp) - 0.5;
    const float f1 = (randXorShift() * temp) - 0.5;
    const float f2 = (randXorShift() * temp) - 0.5;

    float3 normalF3 = normalize(float3(f0, f1, f2)) * 0.8f * randXorShift() * temp;
    particles[id].position = float3(normalF3.x + mousePosition.x, normalF3.y + mousePosition.y, normalF3.z + 3);
    // reset the life of this particle
    particles[id].life     = 4;
    particles[id].velocity = 0;
}

[numthreads(256, 1, 1)]
void CSParticle(uint3 id : SV_DispatchThreadID)
{
    Particle particle = particles[id.x];
    particle.life -= deltaTime;
    if (particle.life <= 0)
    {
        respawn(id.x);
    }
    else
    {
        const float3 direction = normalize(float3(mousePosition, 3) - particle.position);
        particle.velocity += direction;
        particle.position += particle.velocity * deltaTime;
        particles[id.x] = particle;
    }

    const float halfSize = size / 2;
    [unroll(6)]
    for (int i = id.x * 6, j = 0; j < 6; i++, j++)
    {
        Vertex vertex    = vertices[i];
        vertex.position  = particle.position - float3(halfSize, halfSize, 0);
        vertex.position += float3(vertex.uv * size, 0);
        vertex.life      = particle.life;
        vertices[i]      = vertex;
    }
}
