// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Circles
#pragma kernel Clear

struct Circle
{
    float2 origin;
    float2 velocity;
    float radius;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
shared RWTexture2D<float4> output;
StructuredBuffer<Circle> buffer;
int textureResolution;
float4 clearColour;
float4 circleColour;
float time;

/*
 * Returns pseudo random number in range 0 <= x < 1
 */
float random(const float value, const float seed = 0.546)
{
    return frac(sin(value + seed) * 143758.5453);
}

float2 random2(const float value)
{
    return float2(random(value, 3.9812), random(value, 7.1536));
}

float2 mod(const float2 n, const float m)
{
	return ((n % m) + m) % m;
}

void plot1(const int x, const int y, int2 center)
{
    output[uint2(center.x + x, center.y + y)] = circleColour;
}

void plot8(const int x, const int y, const int2 center)
{
    plot1( x,  y, center); plot1( y,  x, center);
    plot1( x, -y, center); plot1( y, -x, center);
    plot1(-x, -y, center); plot1(-y, -x, center);
    plot1(-x,  y, center); plot1(-y,  x, center);
}

void drawCircle(const int2 center, const int radius)
{
    int x = 0;
    int y = radius;
    int d = 1 - radius;

    while (x < y)
    {
        if (d < 0)
        {
            d += (2 * x) + 3;
        }
        else
        {
            d += (2 * (x - y)) + 5;
            y--;
        }

        plot8(x, y, center);
        x++;
    }
}

[numthreads(32, 1, 1)]
void Circles(uint3 id : SV_DispatchThreadID)
{
	const Circle circle = buffer[id.x];
    const int radius    = circle.radius;
    const int2 center   = mod(circle.origin + (circle.velocity * time), textureResolution);

    drawCircle(center, radius);
}

[numthreads(8, 8, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    output[id.xy] = clearColour;
}
